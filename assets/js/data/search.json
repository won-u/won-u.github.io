[ { "title": "[Raspberrypi4] Raspberrypi4 에서 vscode server 실행", "url": "/posts/codeserver-on-rpi4/", "categories": "raspberrypi4", "tags": "raspberrypi4", "date": "2022-10-10 00:00:00 +0900", "snippet": "Overviewipad를 통해 개발을 해볼까 하는 생각을 가지고 있었는데 vscode server를 설치하여 ipad에서 vscode를 사용 할 수 있다는것을 알게 되었다.다행히도 집에 raspberrypi4가 놀고 있어서 code server를 오픈하고 sub domain을 주면 외부 어디서든 vscode를 사용 할 수 있다!!docker image를 처음부터 만드려다 발견한 code-server docker hub 쉽게 사용 할 수 있을 것 같다.vscode server 설치Image pulldocker pull linuxserver/code-serverContainer 실행docker run -d \\ --name=${code_server_container_name} \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Seoul \\ -e PASSWORD=password `#optional` \\ -e DEFAULT_WORKSPACE=/config/workspace `#optional` \\ -p 8443:8443 \\ -v ${CONFIG_DIR}:/config \\ --restart unless-stopped \\ linuxserver/code-server:latestcode server 접근http://${raspberrypi4_ip}:8443" }, { "title": "[Docker] Docker network driver", "url": "/posts/docker-network-driver/", "categories": "Docker", "tags": "docker", "date": "2022-10-08 00:00:00 +0900", "snippet": "Docker network driver ?docker network create --driver bridge ${bridge_name}UPDATE 예정" }, { "title": "[Docker] Docker root dir 변경", "url": "/posts/docker-image-path/", "categories": "Docker", "tags": "docker", "date": "2022-10-06 00:00:00 +0900", "snippet": "Docker root directory?Docker를 사용하면 docker hub를 통해 image를 받거나 해당 image를 통해 container를 생성하게 된다. 이런 정보들은 전부 어디에 저장이 되는것일까?이런 정보는 Docker Root Dir에 설치가 된다. 해당 위치는 아래와 같이 확인이 가능하다.docker info | grep -i \"Docker Root Dir\"Docker Root Dir: /var/lib/dockersudo tree -L 1 /var/lib/docker/var/lib/docker├── buildkit├── containers├── image├── network├── overlay2├── plugins├── runtimes├── swarm├── tmp├── trust└── volumesRoot Dir 변경docker service stopsystemctl stop dockerdaemon.json 추가 혹은 수정vim /etc/docker/daemon.json{ \"data-root\": \"/docker/root/dir\"}docker service stopsystemctl start docker" }, { "title": "[Docker] Docker HTTP private registry 사용", "url": "/posts/docker-http-private-registry/", "categories": "Docker", "tags": "docker", "date": "2022-10-05 00:00:00 +0900", "snippet": "OverviewDocker private registry에서 이미지를 pull, push 할 때 http: server gave HTTP response to HTTPS client 에러가 발생을 하였다.이유는 docker는 registry에 접근할 때 기본 인증으로 안전하지 않은 레지스트리를 사용할 수 없다.하지만 내부망 내에서 사용하던가 정책상 HTTPS 사용이 불가능한 경우에는 HTTP를 사용해야 하는 경우가 있기 때문에 해결 방법이 필요하다.해결 방법/etc/docker/daemon.json 파일에 아래 내용을 추가 한다.$ vim /etc/docker/daemon.json{\t\"insecure-registries\": [\"registry_ip:5000\"]}$ systemctl restart docker이후 regitry로 부터 pull을 하면 정상 동작하는 것을 확인 할 수 있다." }, { "title": "[Docker] Docker 명령어", "url": "/posts/docker-command/", "categories": "Docker", "tags": "docker", "date": "2022-10-02 00:00:00 +0900", "snippet": "사용하기Docker의 명령은 docker run, docker push와 같이 docker &lt;명령&gt; 형식입니다. 그리고 항상 root 권한으로 실행해야 합니다.먼저 Docker의 기본적인 사용법을 알아보기 위해 Docker Hub에서 제공하는 이미지를 받아서 실행해보겠습니다.이미지 검색Docker는 Docker Hub를 통해 이미지를 공유하는 생태계가 구축되어 있습니다. search 명령으로 Docker Hub에서 이미지를 검색할 수 있습니다.sudo docker search &lt;${image_name}&gt;이미지 목록 출력sudo docker images이미지 받기sudo docker pull &lt;${image_name}&gt;sudo docker pull &lt;${image_name}&gt;:&lt;${tag}&gt;sudo docker pull &lt;${user_id}&gt;/&lt;${image_name}&gt;:&lt;${tag}&gt;e.g.)sudo docker pull ubusudo docker rmi ubuntu:16.04sudo docker pull ubuntu:latestsudo docker pull ubuntu:16.04sudo docker pull ian/ubuntu:16.04이미지 컨테이너 생성sudo docker run &lt;${option}&gt; &lt;${image_name}&gt; &lt;${exec_file}&gt;e.g.)sudo docker run -i -t --name hello_world ubuntu:16.04 /bin/bash컨테이너 생성 주요 옵션-i # interactive-t # Allocate a pseudo-TTY-v # Bind mount a volume-w # Working directory inside the container-p # Publish a container's port(s) to the host-P # Publish all exposed ports to random ports-h # Container host name--name # Assign a name to the container컨테이너 목록sudo docker ps -a컨테이너 시작sudo docker start &lt;${container_name}&gt;|&lt;${container_id}&gt;e.g.)sudo docker start hello_world컨테이너 재 시작sudo docker restart &lt;${container_name}&gt;|&lt;${container_id}&gt;e.g.)sudo docker restart hello_world컨테이너 접근sudo docker attach &lt;${container_name}&gt;|&lt;${container_id}&gt;e.g.)sudo docker attach hello_world/bin/bash 를 실행한 container는 입/출력 모두 가능하지만 DB 혹은 Application 실행 시 출력만 가능Bash Shell에서 exit 또는 Ctrl+D를 입력하면 컨테이너가 정지됩니다. 여기서는 Ctrl+P, Ctrl+Q를 차례대로 입력하여 컨테이너를 정지하지 않고, 컨테이너에서 빠져나옵니다.컨테이너 명령어 실행sudo docker exec &lt;${container_name}&gt; &lt;${command}&gt; &lt;${arg...}&gt;e.g.)sudo docker exec hello_world echo \"Hello World\"sudo docker exec -it hell_world /bin/bashdocker exec &lt;컨테이너 이름&gt; &lt;명령&gt; &lt;매개 변수&gt; 형식입니다. 컨테이너 이름 대신 컨테이너 ID를 사용해도 됩니다. 컨테이너가 실행되고 있는 상태에서만 사용할 수 있으며 정지된 상태에서는 사용할 수 없습니다.컨테이너 안의 echo 명령을 실행하고 매개 변수로 “Hello World”를 지정했기 때문에 Hello World가 출력됩니다. docker exec 명령은 이미 실행된 컨테이너에 apt-get, yum 명령으로 패키지를 설치하거나, 각종 데몬을 실행할 때 활용할 수 있습니다.컨테이너 정지sudo docker stop &lt;${container_name}&gt;e.g.)sudo docker stop hello_world컨테이너 삭제sudo docker rm &lt;${container_name}&gt;e.g.)sudo docker rm hello_world이미지 삭제sudo docker rmi &lt;${iamage_name}&gt;sudo docker rmi &lt;${iamage_name}&gt;:&lt;${tag}&gt;sudo docker rmi &lt;${user_name}&gt;/&lt;${iamage_name}&gt;:&lt;${tag}&gt;e.g.)sudo docker rmi ubuntusudo docker rmi ubuntu:16.04sudo docker rmi ian/ubuntu:16.04이미지 생성DockerfileFROM ubuntu:16.04MAINTAINER Ian Won &lt;ian.won@obigo.com&gt;RUN apt-get updateRUN apt-get install -y nginxRUN echo \"\\ndaemon off;\" &gt;&gt; /etc/nginx/nginx.confRUN chown -R www-data:www-data /var/lib/nginxVOLUME [\"/data\", \"/etc/nginx/site-enabled\", \"/var/log/nginx\"]WORKDIR /etc/nginxCMD [\"nginx\"]COPY . .ADD /my/test/data /dataEXPOSE 80EXPOSE 443RUN useradd docker_testRUN passwd -e docker_testUSER docker_test FROM: 어떤 이미지를 기반으로 할지 설정합니다. Docker 이미지는 기존에 만들어진 이미지를 기반으로 생성합니다. &lt;이미지 이름&gt;:&lt;태그&gt; 형식으로 설정합니다. MAINTAINER: 메인테이너 정보입니다. RUN: Shell 스크립트 혹은 명령을 실행합니다. 이미지 생성 중에는 사용자 입력을 받을 수 없으므로 apt-get install 명령에서 y 옵션을 사용합니다(yum install도 동일). 나머지는 nginx 설정입니다. VOLUME: 호스트와 공유할 디렉터리 목록입니다. docker run 명령에서 v 옵션으로 설정할 수 있습니다. 예) v /root/data:/data 호스트의 /root/data 디렉터리를 Docker 컨테이너의 /data 디렉터리에 연결합니다. CMD: 컨테이너가 시작되었을 때 실행할 실행 파일 또는 스크립트입니다. WORKDIR: CMD에서 설정한 실행 파일이 실행될 디렉터리입니다. EXPOSE: 호스트와 연결할 포트 번호입니다. COPY: 호스트 파일/디렉토리 를 docker 이미지의 파일시스템으로 복사 ADD: Copy명령문과 같으며 압축파일, 네트워크상의 파일 등도 가능.dockerignoredockerignore 파일 생성시 Docker 이미지 생성 시 이미지안에 들어가지 않을 파일을 지정 할 수 있습니다..git*.md컨테이너 파일복사sudo docker cp &lt;${container_name}&gt;:&lt;${file_path}&gt;/&lt;${file_name}&gt; &lt;${dest_path}&gt;e.g.)sudo docker cp hello_world:/data/file/test.sh /home/${USER}/copydocker cp &lt;컨테이너 이름&gt;:&lt;경로&gt; &lt;호스트 경로&gt; 형식입니다.컨테이너 실행 명령sudo docker exec ${container_name} ${command}e.g.)sudo docker exec -it test-image /bin/bashdocker exec &lt;옵션&gt; &lt;컨테이너 이름&gt; &lt;커맨드&gt; &lt;ARGUMENTS&gt; 형식입니다.컨테이너 로그 확인sudo docker logs ${container_name}e.g.)sudo docker logs test-imagesudo docker logs -f test-imagedocker logs &lt;옵션&gt; &lt;컨테이너 이름&gt; 형식입니다." }, { "title": "[Docker] Docker 설치 방법", "url": "/posts/docker-how-to-install/", "categories": "Docker", "tags": "docker", "date": "2022-10-01 00:00:00 +0900", "snippet": "설치 스크립트를 통한 설치Docker는 리눅스 배포판 종류를 자동으로 인식하여 패키지를 설치해주는 스크립트를 제공합니다.sudo wget -qO- https://get.docker.com/ | sh우분투 apt를 통한 설치sudo apt-get updatesudo apt-get install docker.iodocker 서비스 실행sudo service docker start부팅했을 때 자동으로 실행하기sudo chkconfig docker ondocker 사용 권한sudo usermod -aG docker $USER" }, { "title": "[Yocto] Yocto variable glossary (사용 빈도수 높은것만)", "url": "/posts/yocto-variable/", "categories": "Yocto", "tags": "yocto, embedded, programming", "date": "2022-09-30 00:00:00 +0900", "snippet": "ALLOW_EMPTY출력 패키지가 비어 있는 경우에도 출력 패키지를 생성할지 여부를 지정합니다. 기본적으로 BitBake는 빈 패키지를 생성하지 않습니다. 이 기본 동작은 RDEPENDS 또는 패키지 존재에 대한 기타 하드 런타임 요구 사항이 있는 경우 문제를 일으킬 수 있습니다.ALLOW_EMPTY:${PN} = \"1\"ALLOW_EMPTY:${PN}-dev = \"1\"ALLOW_EMPTY:${PN}-staticdev = \"1\"AUTOREVSRCREV가 이 변수의 값으로 설정되면 저장소의 최신 소스 리비전을 사용하도록 지정됩니다. 다음은 한 가지 예입니다.SRCREV = \"${AUTOREV}\"BOpenEmbedded 빌드 시스템이 레시피의 빌드 프로세스 중에 생성된 개체를 배치하는 빌드 디렉토리 내의 디렉토리입니다. 기본적으로 이 디렉토리는 다음과 같이 정의된 S 디렉토리와 동일합니다.S = \"${WORKDIR}/${BP}\"BBCLASSEXTEND 하나의 레시피에서 native용(e.g., x86_64)과 target용(e.g., aarch64) 둘다 만들 수 있다. target architecture은 현재 환경의 MACHINE에 영향을 받는다. native용으로 레시피를 따로 만드는 것은 매우 낭비인데, Yocto에서는 native.bbclass 를 사용해, native용으로 레시피를 따로 만들지 않아도 되게한다. BBCLASSEXTEND = \"native\"만 레시피에 써주자. BBCLASSEXTEND =+ \"native nativesdk\"BBCLASSEXTEND =+ \"multilib:multilib_name\"BBLAYERS빌드 중에 활성화할 레이어를 나열합니다. 이 변수는 빌드 디렉토리의 bblayers.conf 구성 파일에 정의되어 있습니다. 다음은 예입니다.BBLAYERS = \" \\ /home/scottrif/poky/meta \\ /home/scottrif/poky/meta-poky \\ /home/scottrif/poky/meta-yocto-bsp \\ /home/scottrif/poky/meta-mykernel \\ \"BBMASKBitBake가 레시피 및 레시피 추가 파일을 처리하는 것을 방지합니다.BBMASK 변수를 사용하여 이러한 .bb 및 .bbappend 파일을 숨길 수 있습니다. BitBake는 표현식과 일치하는 레시피 또는 레시피 추가 파일을 무시합니다. BitBake가 그것들을 전혀 보지 못하는 것과 같습니다. 결과적으로 일치하는 파일은 구문 분석되거나 BitBake에서 사용되지 않습니다.다음 예는 완전한 정규식을 사용하여 BitBake가 meta-ti/recipes-misc/ 디렉토리에 있는 모든 레시피 및 레시피 추가 파일을 무시하도록 지시합니다.BBMASK = \"meta-ti/recipes-misc/\"여러 디렉터리 또는 레시피를 마스킹하려면 여러 정규식 조각을 지정할 수 있습니다. 다음 예는 여러 디렉토리와 개별 레시피를 마스킹합니다.BBMASK += \"/meta-ti/recipes-misc/ meta-ti/recipes-ti/packagegroup/\"BBMASK += \"/meta-oe/recipes-support/\"BBMASK += \"/meta-foo/.*/openldap\"BBMASK += \"opencv.*\\.bbappend\"BBMASK += \"lzma\"💡 디렉토리 이름을 지정할 때 후행 슬래시 문자를 사용하여 해당 디렉토리 이름과 일치하는지 확인하십시오.BP기본 레시피 이름과 버전이지만 특별한 레시피 이름 접미사는 없습니다(예: -native, lib64- 등). BP는 다음으로 구성됩니다.${BPN}-${PV}BPN이 변수는 nativesdk-, -cross, -native 및 multilib의 lib64- 및 lib32-와 같이 공통 접두사 및 접미사가 제거된 PN 변수 버전입니다.제거된 접두사 및 접미사의 정확한 목록은 각각 MLPREFIX 및 SPECIAL_PKGSUFFIX 변수에 의해 지정됩니다.BUILDDIR빌드 디렉토리의 위치를 가리킵니다. 스크립트를 실행할 때 빌드 디렉토리 경로를 전달하여 oe-init-build-env 스크립트를 통해 이 디렉토리를 간접적으로 정의할 수 있습니다.스크립트를 실행하고 빌드 디렉토리 경로를 제공하지 않으면 BUILDDIR은 기본적으로 현재 디렉토리에서 빌드합니다.D대상 디렉토리. do_install 태스크에 의해 구성요소가 설치되는 빌드 디렉토리의 위치입니다. 이 위치의 기본값은 다음과 같습니다.${WORKDIR}/image💡 이 디렉토리에서 읽거나 쓰는 작업은 fakeroot에서 실행되어야 합니다.DEPENDS레시피의 빌드 시간 종속성을 나열합니다. 이는 빌드 시 레시피에 콘텐츠(예: 헤더 및 공유 라이브러리)가 필요한 다른 레시피에 대한 종속성입니다.예를 들어 다음 할당을 포함하는 레시피 foo를 고려하십시오.DEPENDS = \"bar\"이전 할당의 실질적인 효과는 foo에 대한 do_configure 작업이 실행될 때 STAGING_DIR* 변수에 의해 제공된 적절한 스테이징 시스템 루트에서 bar로 설치된 모든 파일을 사용할 수 있다는 것입니다. 이 메커니즘은 기본 클래스의 [deptask] 선언을 통해 DEPENDS에 나열된 각 레시피의 do_populate_sysroot 작업에 do_configure가 종속되도록 하여 구현됩니다.💡 예를 들어 STAGING_DIR_HOST를 명시적으로 참조할 필요는 거의 없습니다. 표준 클래스 및 빌드 관련 변수는 적절한 스테이징 시스템 루트를 자동으로 사용하도록 구성됩니다.DEPLOY_DIROpenEmbedded 빌드 시스템이 빌드 시스템 외부에서 사용할 준비가 된 이미지, 패키지, SDK 및 기타 출력 파일을 배치하는 데 사용하는 일반 영역을 가리킵니다. 기본적으로 이 디렉토리는 ${TMPDIR}/deploy로 빌드 디렉토리 내에 있습니다.빌드 디렉토리의 구조에 대한 자세한 정보는 “빌드 디렉토리 - build/” 섹션을 참조하십시오. 배포 디렉토리의 내용에 대한 자세한 내용은 Yocto 프로젝트 개요 및 개념 매뉴얼의 “이미지”, “패키지 피드” 및 “애플리케이션 개발 SDK” 섹션을 모두 참조하십시오.DEPLOY_DIR_IMAGEOpenEmbedded 빌드 시스템이 대상 시스템에 배포할 준비가 된 이미지 및 기타 관련 출력 파일을 배치하는 데 사용하는 영역을 가리킵니다. 디렉토리는 ${MACHINE} 이름을 포함하므로 시스템에 따라 다릅니다. 기본적으로 이 디렉토리는 ${DEPLOY_DIR}/images/${MACHINE}/로 빌드 디렉토리에 있습니다.파일을 배포할 때 레시피에서 직접 사용해서는 안 됩니다. 대신, 레시피가 의존성에 의해 이미 배포된 파일을 “읽어야” 할 때만 유용합니다. 따라서 배포 클래스로 DEPLOYDIR의 내용을 채우거나 image class에서 IMGDEPLOYDIR의 내용으로 채워야 합니다.빌드 디렉토리의 구조에 대한 자세한 정보는 “빌드 디렉토리 - build/” 섹션을 참조하십시오. 배포 디렉토리의 내용에 대한 자세한 내용은 Yocto 프로젝트 개요 및 개념 매뉴얼의 “이미지” 및 “애플리케이션 개발 SDK” 섹션을 참조하십시오.DEPLOYDIR배포 클래스를 상속할 때 DEPLOYDIR은 다음과 같이 배포 클래스에 설정된 배포된 파일의 임시 작업 영역을 가리킵니다.DEPLOYDIR = \"${WORKDIR}/deploy-${PN}\"배포 클래스를 상속하는 레시피는 배포할 파일을 DEPLOYDIR에 복사해야 하며 나중에 클래스가 파일을 DEPLOY_DIR_IMAGE에 복사합니다.DISTRO배포의 짧은 이름입니다. 배포의 긴 이름에 대한 정보는 DISTRO_NAME 변수를 참조하십시오.DISTRO 변수는 루트 이름이 변수의 인수와 동일하고 파일 이름 확장자가 .conf인 배포 구성 파일에 해당합니다. 예를 들어, Poky 배포에 대한 배포 구성 파일의 이름은 poky.conf이고 소스 디렉터리의 meta-poky/conf/distro 디렉터리에 있습니다.해당 poky.conf 파일 내에서 DISTRO 변수는 다음과 같이 설정됩니다.DISTRO = \"poky\"배포 구성 파일은 배포 구성이 포함된 메타데이터 내의 conf/distro 디렉토리에 있습니다. DISTRO 값은 공백을 포함할 수 없으며 일반적으로 모두 소문자입니다.💡 DISTRO 변수가 비어 있으면 기본 구성 세트가 사용되며 이는 소스 디렉토리의 meta/conf/distro/defaultsetup.conf에도 지정됩니다.DISTRO_FEATURES다양한 기능에 대한 배포에서 원하는 소프트웨어 지원. 배포 구성 파일에서 배포 기능을 정의합니다.대부분의 경우 DISTRO_FEATURES에 기능이 있는지 여부는 기능을 선택적으로 지원하는 레시피에 대한 do_configure 작업 중에 구성 스크립트에 제공된 적절한 옵션으로 변환됩니다. 예를 들어 DISTRO_FEATURES에 “x11”을 지정하면 선택적으로 X11을 지원할 수 있는 대상용으로 구축된 모든 소프트웨어에서 X11 지원이 활성화됩니다.두 가지 더 많은 예는 Bluetooth 및 NFS 지원입니다. Yocto 프로젝트와 함께 제공되고 이 변수와 함께 제공할 수 있는 기능의 전체 목록은 “Distro Featrues” 섹션을 참조하세요.EXTRA_OECMAKE추가 CMake 옵션. 추가 정보는 cmake 클래스를 참조하십시오.EXTRA_OECONF추가 구성 스크립트 옵션. 구성 스크립트 옵션 전달에 대한 추가 정보는 PACKAGECONFIG_CONFARGS를 참조하십시오.EXTRA_OEMAKE추가 GNU make 옵션.EXTRA_OEMAKE의 기본값은 ““이므로 필요한 GNU 옵션을 지정하려면 변수를 설정해야 합니다.PARALLEL_MAKE 및 PARALLEL_MAKEINST도 EXTRA_OEMAKE를 사용하여 필요한 플래그를 전달합니다.EXTRA_USERS_PARAMSextrausers 클래스를 상속할 때 이 변수는 이미지 수준의 사용자 및 그룹 작업을 제공합니다. 이것은 사용자 및 그룹 구성을 특정 레시피에 연결하는 useradd 클래스를 사용하는 것과 비교하여 사용자 및 그룹 구성을 제공하는 보다 전역적인 방법입니다.EXTRA_USERS_PARAMS를 사용하여 구성할 수 있는 명령 세트 목록은 extrausers 클래스에 표시됩니다. 다음 명령은 동일한 이름의 일반 Unix 명령에 매핑됩니다.EXTRA_USERS_PARAMS = \"\\useradd -p '' tester; \\groupadd developers; \\userdel nobody; \\groupdel -g video; \\groupmod -g 1020 developers; \\usermod -s /bin/sh tester; \\\"EXTRA_USERS_PARAMS exampleINHERIT:append = \" extrausers\"EXTRA_IMAGE_FEATURES:append = \" \\ allow-empty-password \\\"EXTRA_USERS_PARAMS:append = \" \\ useradd -d /home/${@d.getVar('USER_ACCOUNT')} -p '' ${@d.getVar('USER_ACCOUNT')}; \\ usermod -s /bin/sh -aG adm ${@d.getVar('USER_ACCOUNT')}; \\\"INHERIT:append = \" extrausers\"EXTRA_USERS_PARAMS:append = \" \\ usermod -s /sbin/nologin root; \\\"FILES패키지에 배치된 파일 및 디렉터리 목록입니다. 그 PAGACKES 변수는 패키지를 나열합니다. 레시피에 의해 생성된. FILES 변수를 사용하려면 패키지 이름 재정의를 제공하십시오. 결과 패키지를 식별합니다. 그런 다음 공백으로 구분하여 입력합니다. 포함할 파일을 식별하는 파일 또는 경로 목록 결과 패키지의 일부입니다. 다음은 한 가지 예입니다.FILES:${PN} += \"${bindir}/mydir1 ${bindir}/mydir2/myfile\"💡 파일이나 경로를 지정할 때 Python의 glob 구문을 사용하여 패턴 일치를 지정할 수 있습니다. 구문에 대한 자세한 내용은 이전 링크를 따라 설명서를 참조하십시오.💡 FILES 변수의 일부로 경로를 지정할 때 적절한 경로 변수를 사용하는 것이 좋습니다. 예를 들어, /etc 대신 ${sysconfdir}을 사용하거나 /usr/bin 대신 ${bindir}을 사용합니다. 소스 디렉토리의 meta/conf/bitbake.conf 파일 상단에서 이러한 변수 목록을 찾을 수 있습니다. 또한 이 파일에서 다양한 FILES:* 변수의 기본값을 찾을 수 있습니다.FILES 변수와 함께 제공한 파일 중 일부가 편집 가능하고 패키지 관리 시스템(PMS)에서 패키지 업데이트 프로세스 동안 덮어쓰지 않아야 한다는 것을 알고 있는 경우 PMS가 덮어쓰지 않도록 이러한 파일을 식별할 수 있습니다. PMS에서 이러한 파일을 식별하는 방법에 대한 정보는 CONFFILES 변수를 참조하십시오.FILEEXTRAPATHSOpenEmbedded 빌드 시스템이 레시피를 처리하고 파일을 추가할 때 파일과 패치를 찾을 때 사용하는 검색 경로를 확장합니다. BitBake가 레시피를 처리할 때 사용하는 기본 디렉토리는 처음에 FILESPATH 변수에 의해 정의됩니다. FILESEXTRAPATHS를 사용하여 FILESPATH 변수를 확장할 수 있습니다.모범 사례에 따르면 .bbappend 파일 내에서 FILESEXTRAPATHS를 사용하고 다음과 같이 경로를 앞에 추가합니다.FILESEXTRAPATHS:prepend := \"${THISDIR}/${PN}:\"위의 예에서 빌드 시스템은 먼저 해당 추가 파일과 동일한 이름을 가진 디렉토리에서 파일을 찾습니다.💡 FILESEXTRAPATHS를 확장할 때 즉시 확장(:=) 연산자를 사용해야 합니다. 즉시 확장은 확장으로 인해 필요한 파일이 포함되지 않은 디렉토리가 발생할 수 있는 나중에가 아니라 지시문이 발생할 때 BitBake가 THISDIR를 평가하도록 합니다.또한 앞에 추가하는 경우 후행 분리 콜론 문자를 포함하십시오. 검색 경로 앞에 디렉토리를 추가하여 경로를 확장하도록 BitBake에 지시하기 때문에 후행 콜론 문자가 필요합니다.또 다른 일반적인 용도는 다음과 같습니다.FILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"이 예에서 빌드 시스템은 FILESPATH 변수를 확장하여 해당 추가 파일과 동일한 디렉토리에 있는 files라는 디렉토리를 포함합니다.다음 예에서는 구체적으로 세 가지 경로를 추가합니다.FILESEXTRAPATHS:prepend := \"path_1:path_2:path_3:\"마지막 예는 검색 경로를 확장하고 BSP 계층에서 유용한 MACHINE 특정 재정의를 포함하는 방법을 보여줍니다.FILESEXTRAPATHS:prepend:intel-x86-common := \"${THISDIR}/${PN}:\"HOSTTOOLS빌드 작업 내에서 호출할 수 있어야 하는 빌드 호스트의 도구 목록(필터)은 공백으로 구분됩니다. 이 필터를 사용하면 호스트 오염 가능성을 줄이는 데 도움이 됩니다. HOSTTOOLS 값에 지정된 도구가 빌드 호스트에서 발견되지 않으면 OpenEmbedded 빌드 시스템에서 오류가 발생하고 빌드가 시작되지 않습니다.추가 정보는 HOSTTOOLS_NONFATAL을 참조하십시오.IMAGE_CLASSES모든 이미지가 상속해야 하는 클래스 목록입니다. 일반적으로 이 변수를 사용하여 OpenEmbedded 빌드 시스템이 생성하는 다양한 유형의 이미지를 등록하는 클래스 목록을 지정합니다.IMAGE_CLASSES의 기본값은 image_types입니다. 이 변수는 local.conf 또는 배포 구성 파일에서 설정할 수 있습니다.자세한 내용은 소스 디렉토리의 meta/classes/image_types.bbclass를 참조하십시오.IMAGE_FEATURES이미지에 포함할 기본 기능 목록입니다. 일반적으로 이미지 레시피에서 이 변수를 구성합니다. Build Directory에 있는 local.conf 파일에서 이 변수를 사용할 수 있지만 모범 사례에서는 사용하지 않는 것이 좋습니다.💡 To enable extra features from outside the image recipe, use the EXTRA_IMAGE_FEATURES variable.Yocto 프로젝트와 함께 제공되는 이미지 기능 목록은 “Image Featrues” 섹션을 참조하세요.이 변수를 사용하여 이미지를 사용자 정의하는 방법을 보여주는 예제는 Yocto 프로젝트 개발 작업 매뉴얼의 “Customizing Images Using Custom IMAGE_FEATURES and EXTRA_IMAGE_FEATURES” 섹션을 참조하십시오.IMAGE_FSTYPES루트 파일 시스템을 생성할 때 빌드 중에 OpenEmbedded 빌드 시스템이 사용하는 형식을 지정합니다. 예를 들어, IMAGE_FSTYPES를 다음과 같이 설정하면 빌드 시스템이 .ext3 및 .tar.bz2의 두 가지 형식을 사용하여 루트 파일 시스템을 생성합니다.IMAGE_FSTYPES = \"ext3 tar.bz2\"선택할 수 있는 지원되는 이미지 형식의 전체 목록은 IMAGE_TYPES를 참조하세요.💡 이미지 레시피가 “inherit image” 행을 사용하고 레시피 내에서 IMAGE_FSTYPES를 설정하는 경우 “이미지 상속” 행을 사용하기 전에 IMAGE_FSTYPES를 설정해야 합니다.OpenEmbedded 빌드 시스템이 이 변수를 처리하는 방식으로 인해 :append 또는 :prepend를 사용하여 내용을 업데이트할 수 없습니다. IMAGE_FSTYPES 변수에 하나 이상의 옵션을 추가하려면 += 연산자를 사용해야 합니다.IMAGE_INSTALL이미지 클래스를 통해 이미지에 설치할 패키지를 지정하기 위해 레시피에서 사용합니다. 순서 문제를 피하기 위해 IMAGE_INSTALL 변수를 주의해서 사용하십시오.이미지 레시피는 image.bbclass를 통해 이미지에 설치할 패키지를 지정하도록 IMAGE_INSTALL을 설정합니다. 또한 IMAGE_FEATURES와 함께 사용되는 목록을 기본 내용과 함께 IMAGE_INSTALL에서 자동 생성 항목으로 전환할 수 있는 core-image 클래스와 같은 “helper” 클래스가 있습니다.이 변수를 사용할 때는 다음과 같이 사용하는 것이 가장 좋습니다.IMAGE_INSTALL:append = \" package-name\"따옴표 문자와 패키지 이름의 시작 부분 사이에 공백을 포함해야 합니다.IMAGE_POSTPROCESS_COMMANDOpenEmbedded 빌드 시스템이 최종 이미지 출력 파일을 생성하면 호출할 함수 목록을 지정합니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.IMAGE_POSTPROCESS_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.IMAGE_PREPROCESS_COMMANDOpenEmbedded 빌드 시스템이 최종 이미지 출력 파일을 생성하기 전에 호출할 함수 목록을 지정합니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.IMAGE_PREPROCESS_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.IMAGE_ROOTFS루트 파일 시스템이 구성 중일 때(예: do_rootfs 작업 중) 위치. 이 변수는 구성할 수 없습니다. 변경하지 마십시오.IMAGE_TYPESSpecifies the complete list of supported image types by default: btrfs container cpio cpio.gz cpio.lz4 cpio.lzma cpio.xz cramfs erofs erofs-lz4 erofs-lz4hc ext2 ext2.bz2 ext2.gz ext2.lzma ext3 ext3.gz ext4 ext4.gz f2fs hddimg iso jffs2 jffs2.sum multiubi squashfs squashfs-lz4 squashfs-lzo squashfs-xz tar tar.bz2 tar.gz tar.lz4 tar.xz tar.zst ubi ubifs wic wic.bz2 wic.gz wic.lzmaFor more information about these types of images, see meta/classes/image_types*.bbclass in the Source Directory.IMGDEPLOYDIR이미지 클래스를 직접 또는 core-image 클래스를 통해 상속할 때 IMGDEPLOYDIR은 다음과 같이 이미지 클래스에 설정된 배포된 파일의 임시 작업 영역을 가리킵니다.IMGDEPLOYDIR = \"${WORKDIR}/deploy-${PN}-image-complete\"이미지 클래스를 상속하는 레시피는 IMGDEPLOYDIR에 배포할 파일을 복사해야 하며, 나중에 클래스가 해당 파일을 DEPLOY_DIR_IMAGE에 복사합니다.INCOMPATIBLE_LICENSE빌드에서 제외해야 하는 라이센스 이름의 공백으로 구분된 목록(LICENSE에 표시됨)을 지정합니다. 나열된 호환되지 않는 라이선스에 대한 대안을 제공하지 않는 레시피는 빌드되지 않습니다. 지정된 호환되지 않는 라이선스로 개별적으로 라이선스가 부여된 패키지는 삭제됩니다.이 변수의 값에 와일드카드에 대한 일부 지원이 있지만 특정 라이선스로 제한됩니다. 현재 이러한 와일드카드만 허용되며 다음과 같이 확장됩니다. AGPL-3.0*\": AGPL-3.0-only, AGPL-3.0-or-later GPL-3.0*: GPL-3.0-only, GPL-3.0-or-later LGPL-3.0*: LGPL-3.0-only, LGPL-3.0-or-later💡 이 기능은 다음 설정을 사용하는 경우에만 정기적으로 테스트됩니다.INCOMPATIBLE_LICENSE = \"GPL-3.0* LGPL-3.0* AGPL-3.0*\"다른 설정을 사용할 수 있지만 기능 시스템 이미지를 생성하는 데 필요한 구성 요소에 대한 종속성을 제거하거나 대안을 제공해야 할 수 있습니다.INHERIT명명된 클래스가 전역적으로 상속되도록 합니다. 클래스 또는 클래스의 익명 기능은 기본 구성 및 각 개별 레시피에 대해 실행되지 않습니다. OpenEmbedded 빌드 시스템은 개별 레시피에서 INHERIT에 대한 변경 사항을 무시합니다.INHERIT에 대한 자세한 내용은 Bitbake 사용자 매뉴얼의 “INHERIT Configuration Directive” 섹션을 참조하십시오.INHIBIT_PACKAGE_DEBUG_SPLITOpenEmbedded 빌드 시스템이 패키징하는 동안 디버그 정보를 분리하지 못하도록 합니다. 기본적으로 빌드 시스템은 do_package 작업 중에 디버깅 정보를 분할합니다. 디버그 정보 분할 방법에 대한 자세한 내용은 PACKAGE_DEBUG_SPLIT_STYLE 변수를 참조하세요.빌드 시스템이 패키징 중에 디버그 정보를 분할하지 않도록 하려면 INHIBIT_PACKAGE_DEBUG_SPLIT 변수를 다음과 같이 설정하십시오.INHIBIT_PACKAGE_DEBUG_SPLIT = \"1\"INHIBIT_PACKAGE_SPLIT“1”로 설정하면 빌드가 결과 패키지의 바이너리를 제거하지 않고 -dbg 패키지에 소스 파일이 포함되지 않도록 합니다.기본적으로 OpenEmbedded 빌드 시스템은 바이너리를 제거하고 디버깅 기호를 ${**[PN](https://docs.yoctoproject.org/ref-manual/variables.html?highlight=rrecommends#term-PN)**}-dbg에 넣습니다. 따라서 일반적으로 디버그할 계획인 경우 INHIBIT_PACKAGE_STRIP을 설정하지 않아야 합니다.INITRAMFS_FSTYPES부팅 중에 사용되는 초기 RAM 파일 시스템(initramfs)의 출력 이미지 형식을 정의합니다. 지원되는 형식은 IMAGE_FSTYPES 변수에서 지원하는 형식과 동일합니다.Source Directory의 meta/conf/bitbake.conf 설정 파일에 설정되어 있는 이 변수의 기본값은 “cpio.gz”입니다. 초기 RAM 파일 시스템 initrd 메커니즘과 달리 Linux 커널의 initramfs 메커니즘은 선택적으로 압축된 cpio 아카이브를 기대합니다.INITRAMFS_IMAGE초기 RAM 파일 시스템(initramfs) 이미지를 빌드하는 데 사용되는 이미지 레시피의 PROVIDES 이름을 지정합니다. 즉, INITRAMFS_IMAGE 변수는 사용 중인 루트 파일 시스템 레시피(예: core-image-sato)에 대한 종속성으로 추가 레시피가 빌드되도록 합니다. 제공하는 initramfs 이미지 레시피는 IMAGE_FSTYPES를 INITRAMFS_FSTYPES로 설정해야 합니다.initramfs 이미지는 초기 시스템 초기화에 사용되는 임시 루트 파일 시스템을 제공합니다(예: “실제” 루트 파일 시스템을 찾고 마운트하는 데 필요한 모듈 로드).💡 예제 initramfs 레시피는 소스 디렉토리의 meta/recipes-core/images/core-image-minimal-initramfs.bb 레시피를 참조하세요. 이 샘플 레시피를 initramfs 이미지를 제공하기 위해 빌드된 레시피로 선택하려면 INITRAMFS_IMAGE를 “core-image-minimal-initramfs”로 설정합니다.NITRAMFS_IMAGE 변수를 사용하는 방법을 보려면 소스 디렉토리, image 클래스 및 kernel 클래스의 meta-poky/conf/local.conf.sample.extended 구성 파일을 참조하여 더 많은 정보를 찾을 수도 있습니다.기본값인 INITRAMFS_IMAGE가 비어 있으면 initramfs 이미지가 빌드되지 않습니다.자세한 내용은 생성된 이미지를 커널 이미지 내부에 묶을 수 있도록 하는 INITRAMFS_IMAGE_BUNDLE 변수도 확인할 수 있습니다. 추가적으로, initramfs 이미지 생성에 대한 정보는 Yocto 프로젝트 개발 작업 매뉴얼의 “Building an Initial RAM Filesystem (initramfs) Image” 섹션을 참조하십시오.KERNEL_DEVICETREE생성된 Linux 커널 장치 트리(예: .dtb) 파일의 이름을 지정합니다.💡 장치 트리에 대한 전체 경로를 지정하기 위한 레거시 지원이 있습니다. 그러나 .dtb 파일만 제공하는 것이 좋습니다.이 변수를 사용하기 위해서는 kernel-devicetree 클래스를 상속받아야 한다.IMAGE_INSTALL:append = \" \\ kernel-devicetree \\\"LAYERDEPENDS이 레시피가 의존하는 레이어를 공백으로 구분하여 나열합니다. 선택적으로 레이어 이름 끝에 추가하여 종속성에 대한 특정 레이어 버전을 지정할 수 있습니다. 다음은 예입니다.LAYERDEPENDS_mylayer = \"anotherlayer (=3)\"이 이전 예에서 “anotherlayer” 버전 3은 LAYERVERSION_anotherlayer와 비교됩니다.종속성이 누락되었거나 버전 번호(지정된 경우)가 정확히 일치하지 않으면 오류가 생성됩니다. 이 변수는 conf/layer.conf 파일에서 사용되며 특정 계층의 이름이 접미사로 추가되어야 합니다(예: LAYERDEPENDS_mylayer).LAYERRECOMMENDS이 레이어와 함께 사용하도록 권장되는 레이어를 공백으로 구분하여 나열합니다.선택적으로 레이어 이름 끝에 버전을 추가하여 권장 사항에 대한 특정 레이어 버전을 지정할 수 있습니다. 다음은 예입니다.LAYERRECOMMENDS_mylayer = \"anotherlayer (=3)\"이 이전 예에서 “anotherlayer” 버전 3은 LAYERVERSION_anotherlayer와 비교됩니다.이 변수는 conf/layer.conf 파일에서 사용되며 특정 계층의 이름이 접미사로 추가되어야 합니다(예: LAYERRECOMMENDS_mylayer).MACHINE이미지가 빌드되는 대상 장치를 지정합니다. 빌드 디렉토리에 있는 local.conf 파일에서 MACHINE을 정의합니다. 기본적으로 MACHINE은 QEMU를 사용하여 에뮬레이트되는 x86 기반 아키텍처 시스템인 “qemux86”으로 설정됩니다.MACHINE ?= \"qemux86\"변수는 동일한 이름의 시스템 구성 파일에 해당하며 이를 통해 시스템별 구성이 설정됩니다. 따라서 MACHINE이 “qemux86”으로 설정되면 해당 qemux86.conf 시스템 구성 파일은 meta/conf/machine의 소스 디렉토리에서 찾을 수 있습니다.출하 시 Yocto 프로젝트에서 지원하는 기계 목록은 다음과 같습니다.MACHINE ?= \"qemuarm\"MACHINE ?= \"qemuarm64\"MACHINE ?= \"qemumips\"MACHINE ?= \"qemumips64\"MACHINE ?= \"qemuppc\"MACHINE ?= \"qemux86\"MACHINE ?= \"qemux86-64\"MACHINE ?= \"genericx86\"MACHINE ?= \"genericx86-64\"MACHINE ?= \"beaglebone\"MACHINE ?= \"edgerouter\"마지막 5개는 meta-yocto-bsp 계층에서 제공되는 Yocto 프로젝트 참조 하드웨어 보드입니다.💡 구성에 추가 BSP(보드 지원 패키지) 레이어를 추가하면 MACHINE에 대해 가능한 새로운 설정이 추가됩니다.NO_RECOMMENDATIONS모든 “recommended-only” 패키지의 설치를 방지합니다. 권장 전용 패키지는 RRECOMMENDS 변수를 통해서만 설치되는 패키지입니다. NO_RECOMMENDATIONS 변수를 “1”로 설정하면 이 기능이 켜집니다.NO_RECOMMENDATIONS = \"1\"이 변수를 local.conf 파일에서 전역적으로 설정하거나 레시피 이름 재정의를 사용하여 특정 이미지 레시피에 첨부할 수 있습니다.NO_RECOMMENDATIONS:pn-target_image = \"1\"이 변수를 사용하여 패키지를 설치하지 않기로 선택하고 일부 다른 패키지가 종속되어 있는 경우(예: 레시피의 RDEPENDS 변수에 나열됨) OpenEmbedded 빌드 시스템은 요청을 무시하고 종속성 오류를 피하기 위해 패키지를 설치합니다. .💡 커널 모듈과 같은 특정 시스템 기능에는 일부 권장 패키지가 필요할 수 있습니다. IMAGE_INSTALL 변수를 사용하여 패키지를 추가하는 것은 사용자의 몫입니다.이 변수는 IPK 및 RPM 패키징 백엔드를 사용할 때만 지원됩니다. DEB는 지원되지 않습니다.관련 정보는 BAD_RECOMMENDATIONS 및 PACKAGE_EXCLUDE 변수를 참조하십시오.OEROOT최상위 빌드 환경 설정 스크립트가 제공되는 디렉토리입니다. Yocto 프로젝트는 최상위 빌드 환경 설정 스크립트인 oe-init-build-env를 제공합니다. 이 스크립트를 실행하면 OEROOT 변수가 스크립트가 포함된 디렉토리로 확인됩니다.이 변수가 사용되는 방법에 대한 추가 정보는 초기화 스크립트를 참조하십시오.OVERRIDES현재 적용되는 재정의의 콜론으로 구분된 목록입니다. 재정의는 구문 분석이 끝날 때 변수를 선택적으로 재정의할 수 있는 BitBake 메커니즘입니다. OVERRIDES의 재정의 세트는 현재 빌드 중인 레시피, 빌드 중인 기계 등을 포함하는 빌드 중 “상태”를 나타냅니다.예를 들어, 문자열 “an-override”가 OVERRIDES의 콜론으로 구분된 목록의 요소로 나타나는 경우 다음 할당은 구문 분석이 끝날 때 “overridden” 값으로 FOO를 재정의합니다.FOO:an-override = \"overridden\"재정의 메커니즘에 대한 자세한 정보는 BitBake 사용자 매뉴얼의 “Conditional Syntax (Overrides)” 섹션을 참조하십시오.OVERRIDES의 기본값에는 CLASSOVERRIDE, MACHINEOVERRIDES 및 DISTROOVERRIDES 변수 값이 포함됩니다. 기본적으로 포함된 또 다른 중요한 재정의는 pn-${PN}입니다. 이 재정의를 통해 구성(.conf) 파일 내의 단일 레시피에 대해 변수를 설정할 수 있습니다. 다음은 예입니다.FOO:pn-myrecipe = \"myrecipe-specific value\"💡 어떤 재정의가 적용되는지 확인하는 쉬운 방법은 bitbake -e 명령의 출력에서 OVERRIDES를 검색하는 것입니다. 자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 “Viewing Variable Values” 섹션을 참조하십시오.P레시피 이름 및 버전. P는 다음으로 구성됩니다.${PN}-${PV}PACKAGECONFIG이 변수는 레시피별로 레시피 기능을 활성화 또는 비활성화하는 수단을 제공합니다. PACKAGECONFIG 블록은 기능을 지정한 다음 기능 동작을 정의하는 인수를 지정할 때 레시피에 정의됩니다. 다음은 기본 블록 구조입니다(가독성을 위해 여러 줄로 구분).PACKAGECONFIG ??= \"f1 f2 f3 ...\"PACKAGECONFIG[f1] = \"\\ --with-f1, \\ --without-f1, \\ build-deps-for-f1, \\ runtime-deps-for-f1, \\ runtime-recommends-for-f1, \\ packageconfig-conflicts-for-f1\"PACKAGECONFIG[f2] = \"\\ ... and so on and so on ...PACKAGECONFIG 변수 자체는 활성화할 기능의 공백으로 구분된 목록을 지정합니다. 기능 다음에 쉼표로 구분된 최대 6개의 순서 종속 인수를 제공하여 각 기능의 동작을 결정할 수 있습니다. 원하는 인수를 생략할 수 있지만 구분 쉼표는 유지해야 합니다. 순서는 중요하며 다음을 지정합니다. 기능이 활성화된 경우 구성 스크립트 인수 목록(EXTRA_OECONF 또는 PACKAGECONFIG_CONFARGS)에 추가해야 하는 추가 인수입니다. 기능이 비활성화된 경우 EXTRA_OECONF 또는 PACKAGECONFIG_CONFARGS에 추가해야 하는 추가 인수입니다. 기능이 활성화된 경우 추가해야 하는 추가 빌드 종속성(DEPENDS)입니다. 기능이 활성화된 경우 추가해야 하는 추가 런타임 종속성(RDEPENDS)입니다. 기능이 활성화된 경우 추가해야 하는 추가 런타임 권장 사항(RRECOMMENDS)입니다. 이 기능에 대해 충돌하는(즉, 상호 배타적인) PACKAGECONFIG 설정입니다.librsvg 레시피에서 가져온 다음 PACKAGECONFIG 블록을 고려하십시오. 이 예에서 기능은 기능의 동작을 결정하는 세 가지 인수가 있는 gtk입니다.PACKAGECONFIG[gtk] = \"--with-gtk3,--without-gtk3,gtk+3\"-with-gtk3 및 gtk+3 인수는 기능이 활성화된 경우에만 적용됩니다. 이 경우 구성 스크립트 인수 목록에 –with-gtk3이 추가되고 DEPENDS에 gtk+3이 추가됩니다. 반면에 다른 계층의 .bbappend 파일을 통해 기능이 비활성화된 경우 대신 구성 스크립트에 두 번째 인수 –without-gtk3가 추가됩니다.앞에서 설명한 기본 PACKAGECONFIG 구조는 블록을 생성하든 변경하든 상관없이 적용됩니다. 블록을 생성할 때 레시피 내부의 구조를 사용하십시오.기존 PACKAGECONFIG 블록을 변경하려면 다음 두 가지 방법 중 하나를 수행할 수 있습니다. 파일 추가: 레이어에 recipename.bbappend라는 추가 파일을 만들고 PACKAGECONFIG 값을 재정의합니다. 변수를 완전히 재정의할 수 있습니다.PACKAGECONFIG = \"f4 f5\"또는 변수를 추가할 수 있습니다.PACKAGECONFIG:append = \" f4\" 구성 파일: 이 방법은 local.conf 또는 mydistro.conf 파일을 편집하는 것을 제외하고 추가 파일을 통해 블록을 변경하는 것과 동일합니다. 앞에서 설명한 추가 파일과 마찬가지로 변수를 완전히 재정의할 수 있습니다.PACKAGECONFIG:pn-recipename = \"f4 f5\"또는 변수를 추가할 수 있습니다.PACKAGECONFIG:append:pn-recipename = \" f4\"PN이 변수는 컨텍스트에 따라 두 개의 개별 기능을 가질 수 있습니다: 레시피 이름 또는 결과 패키지 이름.PN은 OpenEmbedded 빌드 시스템이 패키지를 생성하기 위한 입력으로 사용하는 파일 컨텍스트의 레시피 이름을 나타냅니다. 이름은 일반적으로 레시피 파일 이름에서 추출됩니다. 예를 들어, 레시피 이름이 expat_2.0.1.bb인 경우 PN의 기본값은 “expat”입니다.변수는 OpenEmbedded 빌드 시스템에 의해 생성되거나 생성된 파일의 컨텍스트에서 패키지 이름을 참조합니다.해당되는 경우 PN 변수에는 특수 접미사 또는 접두사도 포함됩니다. 예를 들어 bash를 사용하여 기본 시스템용 패키지를 빌드하는 경우 PN은 bash 기본입니다. bash를 사용하여 대상 및 Multilib용 패키지를 빌드하는 경우 PN은 각각 bash 및 lib64-bash가 됩니다.PR레시피의 개정판. 이 변수의 기본값은 “r0”입니다. 레시피의 후속 수정은 일반적으로 “r1”, “r2” 등의 값을 갖습니다. PV가 증가하면 PR은 일반적으로 “r0”으로 재설정됩니다.💡 OpenEmbedded 빌드 시스템은 언제 레시피를 다시 빌드해야 하는지 알기 위해 PR의 도움이 필요하지 않습니다. 빌드 시스템은 stamp 및 Shared State Cache 메커니즘과 함께 작업 input checksums을 사용합니다.PR 변수는 패키지 관리자가 이미 빌드된 이미지에 패키지를 동적으로 설치할 때 주로 중요합니다. 이 경우 PKGR의 기본값인 PR은 많은 패키지가 동일한 PV(즉, PKGV)를 갖는 경우 패키지 관리자가 어떤 패키지가 가장 최근 패키지인지 구별하는 데 도움이 됩니다. 동일한 PV를 가진 많은 패키지가 있는 구성 요소는 일반적으로 패키지가 모두 동일한 업스트림 버전을 설치하지만 패키징 수정 사항을 포함하는 이후(PR) 버전 패키지를 설치한다는 것을 의미합니다.PREFERRED_PROVIDER여러 레시피가 동일한 항목을 제공하는 경우 이 변수는 선호하는 레시피를 결정하여 항목(즉, 기본 제공자)을 제공합니다. 항상 이 변수에 제공된 항목의 이름을 접미사로 붙여야 합니다. 그리고, 선호하는 레시피의 이름(PN)을 사용하여 변수를 정의해야 합니다. 다음은 일반적인 예입니다.PREFERRED_PROVIDER_virtual/kernel ?= \"linux-yocto\"이전 예에서 여러 레시피가 “virtual/kernel”을 제공하고 있습니다. PREFERRED_PROVIDER 변수는 “virtual/kernel”을 제공하려는 레시피의 이름(PN)으로 설정됩니다.다음은 더 많은 예입니다.PREFERRED_PROVIDER_virtual/xserver = \"xserver-xf86\"PREFERRED_PROVIDER_virtual/libgl ?= \"mesa\"자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 “Using Virtual Providers” 섹션을 참조하십시오.💡 가상/* 항목을 PREFERRED_PROVIDER와 함께 사용하는 경우 해당 항목을 제공하지만 PREFERRED_PROVIDER에 의해 선택(정의)되지 않은 모든 레시피가 빌드되지 않습니다. 이는 이 메커니즘이 상호 배타적인 대체 제공자 사이에서 선택하도록 설계되었기 때문에 일반적으로 바람직합니다.PROVIDES특정 레시피를 알 수 있는 별칭 목록입니다. 기본적으로 레시피의 자체 PN은 암시적으로 이미 PROVIDES 목록에 있으므로 자체적으로 제공한다고 언급할 필요가 없습니다. 레시피가 PROVIDES를 사용하는 경우 추가 별칭은 레시피의 동의어이며 DEPENDS에 지정된 대로 빌드 중에 다른 레시피의 종속성을 충족하는 데 유용할 수 있습니다.레시피 파일 eudev_3.2.9.bb에서 다음 예제 PROVIDES 문을 고려하십시오.PROVIDES += \"udev\"PROVIDES 문은 “eudev” 레시피를 단순히 “udev”로도 사용할 수 있게 합니다.💡 레시피 고유의 레시피 이름(PN)은 항상 암시적으로 PROVIDES 앞에 추가되므로 위의 예에서 “+=”를 사용할 필요는 없지만 혼동을 피하기 위해 권장됩니다.대체 이름으로 레시피를 제공하는 것 외에도 PROVIDES 메커니즘을 사용하여 가상 대상을 구현합니다. 가상 대상은 특정 기능(예: Linux 커널)에 해당하는 이름입니다. 문제의 기능을 제공하는 레시피는 PROVIDES의 가상 대상을 나열합니다. 문제의 기능에 의존하는 레시피는 DEPENDS에 가상 타겟을 포함하여 제공자의 선택을 열어둘 수 있습니다.일반적으로 가상 대상은 “가상/기능”(예: “virtual/kernel”) 형식의 이름을 갖습니다. 슬래시는 단순히 이름의 일부이며 구문상 의미가 없습니다.PREFERRED_PROVIDER 변수는 가상 대상을 제공하는 특정 레시피를 선택하는 데 사용됩니다.💡 가상 런타임 종속성(패키지)에 대한 해당 메커니즘이 존재합니다. 그러나 메커니즘은 일반 변수 할당 이외의 특수 기능에 의존하지 않습니다. 예를 들어 VIRTUAL-RUNTIME_dev_manager는 /dev 디렉토리를 관리하는 구성 요소의 패키지를 나타냅니다.런타임 종속성에 대한 “선호 공급자”를 설정하는 것은 구성 파일에서 다음 할당을 사용하는 것만큼 간단합니다.VIRTUAL-RUNTIME_dev_manager = \"udev\"PVPV is the default value of the PKGV variable.레시피의 버전입니다. 버전은 일반적으로 레시피 파일 이름에서 추출됩니다. 예를 들어, 레시피 이름이 expat_2.0.1.bb인 경우 PV의 기본값은 “2.0.1”입니다. PV는 소스 코드 저장소(예: Git 또는 Subversion)에서 불안정한(예: 개발) 버전을 빌드하지 않는 한 일반적으로 레시피 내에서 재정의되지 않습니다.PV는 PKGV 변수의 기본값입니다.RDEPENDS패키지의 런타임 종속성을 나열합니다. 이러한 종속성은 패키지가 올바르게 작동하기 위해 설치해야 하는 다른 패키지입니다. 예를 들어 다음 할당은 패키지 foo에 패키지 bar 및 baz를 설치해야 한다고 선언합니다.RDEPENDS:foo = \"bar baz\"RDEPENDS:${PN}-dev += \"perl\"ROOTFS루트 파일 시스템으로 포함할 파일 시스템 이미지를 나타냅니다.ROOTFS 변수는 image-live 클래스와 함께 사용되는 선택적 변수입니다.ROOTFS_POSTINSTALL_COMMANDOpenEmbedded 빌드 시스템이 패키지를 설치한 후 호출할 함수 목록을 지정합니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.ROOTFS_POSTINSTALL_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.ROOTFS_POSTPROCESS_COMMANDOpenEmbedded 빌드 시스템이 루트 파일 시스템을 만든 후 호출할 함수 목록을 지정합니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.ROOTFS_POSTPROCESS_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.ROOTFS_POSTUNINSTALL_COMMANDOpenEmbedded 빌드 시스템이 불필요한 패키지를 제거한 후 호출할 함수 목록을 지정합니다. 이미지에서 런타임 패키지 관리가 비활성화되면 base-passwd, shadow 및 update-alternatives를 포함한 여러 패키지가 제거됩니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.ROOTFS_POSTUNINSTALL_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.ROOTFS_PREPROCESS_COMMANDOpenEmbedded 빌드 시스템이 루트 파일 시스템을 생성하기 전에 호출할 함수 목록을 지정합니다. 세미콜론으로 구분된 함수를 지정할 수 있습니다.ROOTFS_PREPROCESS_COMMAND += \"function; ... \"함수 내의 명령에 루트 파일 시스템 경로를 전달해야 하는 경우 루트 파일 시스템 이미지가 되는 디렉토리를 가리키는 ${IMAGE_ROOTFS}를 사용할 수 있습니다. 자세한 내용은 IMAGE_ROOTFS 변수를 참조하십시오.RRECOMMENDS빌드 중인 패키지의 사용성을 확장하는 패키지 목록입니다. 빌드 중인 패키지는 성공적으로 빌드하기 위해 이 패키지 목록에 의존하지 않고 확장된 사용성을 위해 사용합니다. 패키지에 대한 런타임 종속성을 지정하려면 RDEPENDS 변수를 참조하십시오.패키지 관리자는 빌드된 패키지를 설치할 때 RRECOMMENDS 패키지 목록을 자동으로 설치합니다. 그러나 BAD_RECOMMENDATIONS, NO_RECOMMENDATIONS 및 PACKAGE_EXCLUDE 변수를 사용하여 나열된 패키지가 설치되는 것을 방지할 수 있습니다.RRECOMMENDS에 지정된 패키지는 실제로 생성할 필요가 없습니다. 그러나 PACKAGES 또는 PACKAGES_DYNAMIC 변수 또는 RPROVIDES 변수를 통해 각 패키지를 제공하는 레시피가 있어야 하며 그렇지 않으면 빌드 중에 오류가 발생합니다. 이러한 레시피가 존재하고 패키지가 생성되지 않으면 빌드가 오류 없이 계속됩니다.RRECOMMENDS 변수는 빌드 중인 패키지에 적용되기 때문에 항상 변수에 재정의를 첨부하여 유용성이 확장되는 특정 패키지를 지정해야 합니다. 예를 들어, 무선 기능을 지원하도록 확장된 개발 패키지를 구축한다고 가정합니다. 이 경우 다음을 사용합니다.RRECOMMENDS:${PN}-dev += \"wireless_package_name\"예에서 패키지 이름(${PN}-dev)은 debian.bbclass와 같은 클래스에 의해 출력 패키지의 이름을 바꾸기 전에 PACKAGES 네임스페이스에서와 같이 나타나야 합니다.OpenEmbedded 빌드 시스템이 사용하는 BitBake는 버전이 지정된 권장 사항 지정을 지원합니다. 구문은 패키징 형식에 따라 다르지만 BitBake는 이러한 차이점을 숨깁니다. 다음은 RRECOMMENDS 변수를 사용하여 버전을 지정하는 일반 구문입니다.RRECOMMENDS:${PN} = \"package (operator version)\"연산자에 대해 다음을 지정할 수 있습니다. = &lt; &lt;= = 예를 들어 다음은 foo 패키지 버전 1.2 이상에 대한 권장 사항을 설정합니다.RRECOMMENDS:${PN} = \"foo (&gt;= 1.2)\"S압축을 푼 레시피 소스 코드가 있는 Build Directory의 위치입니다. 기본적으로 이 디렉토리는 ${WORKDIR}/${BPN}-${PV}입니다. 여기서 ${BPN}은 기본 레시피 이름이고 ${PV}는 레시피 버전입니다. 소스 tarball이 ${BPN}-${PV} 이외의 다른 이름의 디렉토리로 코드를 추출하거나 소스 코드가 Git 또는 Subversion과 같은 SCM에서 가져온 경우 레시피에서 S를 설정해야 다음과 같이 됩니다. OpenEmbedded 빌드 시스템은 압축을 푼 소스를 찾을 위치를 알고 있습니다.예를 들어 poky라는 이름의 소스 디렉토리 최상위 폴더와 poky/build에 기본 빌드 디렉토리가 있다고 가정합니다. 이 경우 빌드 시스템이 db에 대한 압축을 푼 레시피를 유지하는 데 사용하는 작업 디렉터리는 다음과 같습니다.poky/build/tmp/work/qemux86-poky-linux/db/5.1.19-r3/db-5.1.19압축을 푼 소스 코드는 db-5.1.19 폴더에 있습니다.다음 예에서는 Git 리포지토리를 가정합니다. 기본적으로 Git 리포지토리는 do_fetch 동안 ${WORKDIR}/git에 복제됩니다. 이 경로는 기본값 S와 다르기 때문에 소스를 찾을 수 있도록 구체적으로 설정해야 합니다.SRC_URI = \"git://path/to/repo.git;branch=main\"S = \"${WORKDIR}/git\"SDK_NAMESDK 출력 파일의 기본 이름입니다. 이름은 DISTRO, TCLIBC, SDK_ARCH, IMAGE_BASENAME 및 TUNE_PKGARCH 변수에서 파생됩니다.SDK_NAME = \"${DISTRO}-${TCLIBC}-${SDK_ARCH}-${IMAGE_BASENAME}-${TUNE_PKGARCH}\"SRC_URI이 변수 SRC_URI에 대한 초기 설명은 BitBake 매뉴얼을 참조하십시오.다음 기능은 OpenEmbedded 및 Yocto 프로젝트에 의해 추가되었습니다.표준 및 레시피별 옵션이 있습니다. 다음은 표준입니다. apply - 패치 적용 여부. 기본 작업은 패치를 적용하는 것입니다. striplevel - 패치를 적용할 때 사용할 스트립 레벨입니다. 기본 수준은 1입니다. patchdir - 패치를 적용해야 하는 디렉토리를 지정합니다. 기본값은 ${S}입니다.다음은 개정 관리 시스템에서 코드를 빌드하는 레시피에 특정한 옵션입니다. mindate - Apply the patch only if SRCDATE is equal to or greater than mindate. maxdate - Apply the patch only if SRCDATE is not later than maxdate. minrev - Apply the patch only if SRCREV is equal to or greater than minrev. maxrev - Apply the patch only if SRCREV is not later than maxrev. rev - Apply the patch only if SRCREV is equal to rev. notrev - Apply the patch only if SRCREV is not equal to rev.💡 빌드 시스템이 추가 파일에서 SRC_URI 문을 통해 지정된 파일을 선택하도록 하려면 추가 파일 내에서 FILESEXTRAPATHS 변수도 사용하여 FILESPATH 변수를 확장해야 합니다.SRCREV패키지를 빌드하는 데 사용된 소스 코드의 개정판입니다. 이 변수는 Subversion, Git, Mercurial 및 Bazaar에만 적용됩니다. 고정 버전을 만들고 BitBake가 레시피를 구문 분석할 때마다 원격 저장소에서 쿼리를 수행하지 않으려면 태그가 아닌 전체 버전 식별자인 SRCREV를 지정해야 합니다.💡 SRCREV를 사용하여 최신 소프트웨어 개정판을 상속할 때의 제한 사항에 대한 정보는 AUTOREV 변수 설명과 Yocto 프로젝트 개발 작업 매뉴얼에 있는 “Automatically Incrementing a Package Version Number” 섹션을 참조하십시오.TCLIBC빌드 프로세스 중에 사용할 GNU 표준 C 라이브러리(libc) 변형을 지정합니다.“glibc”, “musl”, “newlib” 또는 “baremetal”을 선택할 수 있습니다.WKS_FILE파티션된 이미지(image.wic)를 생성하기 위해 OpenEmbedded 빌드 시스템에서 사용하는 Wic 킥스타트 파일의 위치를 지정합니다. 분할된 이미지를 만드는 방법에 대한 정보는 Yocto 프로젝트 개발 작업 매뉴얼의 “Creating Partitioned Images Using Wic” 섹션을 참조하십시오. 킥스타트 파일 형식에 대한 자세한 내용은 “OpenEmbedded Kickstart (.wks) Reference” 장을 참조하십시오.WORKDIROpenEmbedded 빌드 시스템이 레시피를 빌드하는 작업 디렉터리의 경로 이름입니다. 이 디렉토리는 TMPDIR 디렉토리 구조 내에 있으며 빌드 중인 레시피와 빌드되는 시스템에 따라 다릅니다.WORKDIR 디렉토리는 다음과 같이 정의됩니다.${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}실제 디렉토리는 다음과 같은 몇 가지 사항에 따라 달라집니다. TMPDIR: 최상위 빌드 출력 디렉토리 MULTIMACH_TARGET_SYS: 대상 시스템 식별자 PN: 레시피 이름 EXTENDPE: The epoch - (대부분의 레시피의 경우인 PE가 지정되지 않은 경우 EXTENDPE는 비어 있음) PV: 레시피 버전 PR: 레시피 개정판예를 들어 소스 디렉토리 최상위 폴더 이름 poky, 기본 빌드 디렉토리(poky/build) 및 qemux86-poky-linux 시스템 대상 시스템을 가정합니다. 또한 레시피의 이름이 foo_1.3.0-r0.bb라고 가정합니다. 이 경우 빌드 시스템이 패키지를 빌드하는 데 사용하는 작업 디렉토리는 다음과 같습니다.poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0" }, { "title": "[Yocto] Yocto 빌드", "url": "/posts/yocto-build/", "categories": "Yocto", "tags": "yocto, embedded, programming", "date": "2022-09-23 00:00:00 +0900", "snippet": "OverviewYocto를 통한 배포판 빌드를 위한 간단 가이드를 작성합니다.요구 사항빌드 호스트에서는 아래와 같은 요구사항을 충족하여야 합니다. 50GB 이상의 남은 공간 지원되는 Linux 배포판(예: Fedora, openSUSE, CentOS, Debian 또는 Ubuntu의 최신 릴리스)을 실행합니다. Yocto 프로젝트를 지원하는 Linux 배포판 목록은 Yocto 프로젝트 참조 매뉴얼의 지원되는 Linux 배포판 섹션을 참조하십시오. 빌드 호스트 준비에 대한 자세한 정보는 Yocto 프로젝트 개발 작업 매뉴얼의 빌드 호스트 준비 섹션을 참조하십시오. Git 1.8.3.1 버전 이상 tar 1.28 버전 이상 Python 3.6.0 버전 이상 gcc 7.5 버전 이상 GNU make 4.0 버전 이상빌드 호스트 필요 패키지빌드 호스트에 필수 호스트 패키지를 설치해야 합니다. 다음 명령은 Ubuntu 배포를 기반으로 호스트 패키지를 설치합니다.sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd liblz4-tool💡 지원되는 모든 Linux 배포판에 대한 호스트 패키지 요구 사항은 Yocto 프로젝트 참조 매뉴얼의 빌드 호스트에 필요한 패키지 섹션을 참조하십시오.Poky download$ git clone git://git.yoctoproject.org/pokyCloning into 'poky'...remote: Countingobjects: 432160, done. remote: Compressing objects: 100%(102056/102056), done. remote: Total 432160 (delta 323116), reused432037 (delta 323000) Receiving objects: 100% (432160/432160), 153.81 MiB | 8.54 MiB/s, done.Resolving deltas: 100% (323116/323116), done.Checking connectivity... done.릴리스 위키 페이지로 이동하여 최신 안정 릴리스 또는 장기 지원 릴리스에 해당하는 릴리스 코드명(예: langdale)을 선택하십시오.그런 다음 poky 디렉토리로 이동하여 기존 branch를 살펴봅니다.$ cd poky$ git branch -a...remotes/origin/HEAD -&gt; origin/masterremotes/origin/dunfellremotes/origin/dunfell-next...remotes/origin/gatesgarthremotes/origin/gatesgarth-next...remotes/origin/masterremotes/origin/master-next...Yocto 프로젝트 관련 리포지토리 액세스에 대한 추가 옵션 및 정보는 Yocto 프로젝트 개발 작업 매뉴얼의 Yocto 프로젝트 소스 파일 찾기 섹션을 참조하십시오.이미지 빌드다음 단계를 사용하여 이미지를 빌드합니다. 빌드 프로세스는 소스에서 툴체인을 포함한 전체 Linux 배포판을 생성합니다. 빌드 환경 초기화: poky 디렉토리 내에서 oe-init-build-env 환경 설정 스크립트를 실행하여 빌드 호스트에서 Yocto 프로젝트의 빌드 환경을 정의합니다.$ cd poky$ source oe-init-build-envYou had no conf/local.conf file. This configuration file has therefore beencreated for you with some default values. You may wish to edit it to, forexample, select a different MACHINE (target hardware). See conf/local.conffor more information as common configuration options are commented.You had no conf/bblayers.conf file. This configuration file has thereforebeen created for you with some default values. To add additional metadatalayers into your configuration please add entries to conf/bblayers.conf.The Yocto Project has extensive documentation about OE including a referencemanual which can be found at: https://docs.yoctoproject.orgFor more information about OpenEmbedded see their website: https://www.openembedded.org/### Shell environment set up for builds. ###You can now run 'bitbake &lt;target&gt;'Common targets are: core-image-minimal core-image-full-cmdline core-image-sato core-image-weston meta-toolchain meta-ide-supportYou can also run generated QEMU images with a command like 'runqemu qemux86-64'Other commonly useful commands are: - 'devtool' and 'recipetool' handle common recipe tasks - 'bitbake-layers' handles common layer tasks - 'oe-pkgdata-util' handles common target package tasks 로컬 구성 파일 검사: 빌드 환경을 설정할 때 local.conf라는 로컬 구성 파일을 빌드 디렉토리의 conf 하위 디렉토리에서 사용할 수 있게 됩니다. 이 예에서 기본값은 에뮬레이션에 적합한 qemux86 대상에 대해 빌드하도록 설정됩니다. 사용된 패키지 관리자는 RPM 패키지 관리자로 설정됩니다. 빌드: 다음 명령을 사용하여 대상에 대한 OS 이미지를 빌드합니다. 이 예에서는 core-image-sato입니다. $ bitbake core-image-sato bitbake 명령 사용에 대한 정보는 Yocto 프로젝트 개요 및 개념 매뉴얼의 BitBake 섹션을 참조하거나 BitBake 사용자 매뉴얼의 BitBake 명령을 참조하십시오. QEMU를 사용하여 이미지 시뮬레이션: 이 특정 이미지가 빌드되면 Yocto 프로젝트와 함께 제공되는 빠른 에뮬레이터인 QEMU를 시작할 수 있습니다. $ runqemu qemux86-64 QEMU 실행에 대한 자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 QEMU(Quick EMUlator) 사용 장을 참조하십시오. QEMU 종료: 종료 아이콘을 클릭하거나 QEMU를 불러온 QEMU 스크립트 창에서 Ctrl-C를 입력하여 QEMU를 종료합니다.특정 하드웨어에 대한 사용자 지정지금까지 에뮬레이션에만 적합한 이미지를 빠르게 구축한 것뿐입니다. 이 섹션에서는 Yocto 프로젝트 개발 환경에 하드웨어 Layer을 추가하여 특정 하드웨어에 맞게 빌드를 사용자 정의하는 방법을 보여줍니다.일반적으로 레이어는 Yocto 프로젝트에 수행할 작업을 알려주는 관련 지침 및 구성 세트가 포함된 저장소입니다. 관련 메타데이터를 기능적으로 특정 Layer으로 분리하면 모듈식 개발이 용이하고 Layer 메타데이터를 더 쉽게 재사용할 수 있습니다.💡 규칙에 따라 레이어 이름은 “meta-“ 문자열로 시작합니다.하드웨어 Layer을 추가하려면 다음 단계를 따르십시오. Find a layer: 많은 하드웨어 Layer를 사용할 수 있습니다. Yocto 프로젝트 소스 저장소에는 많은 하드웨어 Layer가 있습니다. 이 예는 meta-altera 하드웨어 Layer을 추가합니다. Layer 복제: Git을 사용하여 시스템에서 Layer의 로컬 복사본을 만듭니다. 이전에 생성한 Poky 저장소 복사본의 최상위 수준의 복사본을 넣을 수 있습니다.$ cd poky$ git clone https://github.com/kraj/meta-altera.gitCloning into 'meta-altera'...remote: Counting objects: 25170, done.remote: Compressing objects: 100% (350/350), done.remote: Total 25170 (delta 645), reused 719 (delta 538), pack-reused 24219Receiving objects: 100% (25170/25170), 41.02 MiB | 1.64 MiB/s, done.Resolving deltas: 100% (13385/13385), done.Checking connectivity... done.이제 하드웨어 Layer는 빌드 호스트의 Poky 참조 repository리 내부의 meta-altera로 사용할 수 있으며 Intel이 소유한 Altera의 하드웨어를 지원하는 데 필요한 모든 메타데이터를 포함합니다.💡 Layer에는 Yocto 프로젝트 릴리스마다 분기가 있는 것이 좋습니다. 사용 중인 Yocto 프로젝트 릴리스를 지원하는 Layer 브랜치를 확인하십시오. 특정 시스템에 대한 구성을 빌드로 변경합니다. local.conf 파일의 MACHINE 변수는 빌드를 위한 시스템을 지정합니다. 이 예에서는 MACHINE 변수를 cyclone5로 설정합니다. 다음 구성이 사용됩니다: https://github.com/kraj/meta-altera/blob/master/conf/machine/cyclone5.conf.💡 빌드 구성에 대한 자세한 내용은 앞의 “로컬 구성 파일 검사” 단계를 참조하십시오. 레이어 구성 파일에 레이어 추가: 빌드 중에 레이어를 사용하려면 먼저 Build Directory conf 디렉터리에 있는 bblayers.conf 파일에 레이어를 추가해야 합니다. bitbake-layers add-layer 명령을 사용하여 구성 파일에 Layer를 추가합니다. $ cd poky/build$ bitbake-layers add-layer ../meta-alteraNOTE: Starting bitbake server...Parsing recipes: 100% |##################################################################| Time: 0:00:32Parsing of 918 .bb files complete (0 cached, 918 parsed). 1401 targets,123 skipped, 0 masked, 0 errors. bitbake-layers 스크립트를 사용하여 Layer 추가 섹션에서 Layer 추가에 대한 자세한 정보를 찾을 수 있습니다. 이 단계를 완료하면 Yocto 프로젝트 개발 환경에 meta-altera Layer가 추가되고 cyclone5 머신용으로 빌드하도록 구성되었습니다. 💡 이전 단계는 데모용입니다. Cyclone5 머신에 대한 이미지를 구축하려는 경우 Altera README를 읽어야 합니다.일반 레이어 만들기격리해야 하는 응용 프로그램이나 특정 동작 집합이 있을 수 있습니다. bitbake-layers create-layer 명령을 사용하여 자신만의 일반 레이어를 생성할 수 있습니다. 이 도구는 layer.conf 구성 파일이 있는 하위 디렉토리, example.bb 레시피가 포함된 recipe-example 하위 디렉토리, 라이선스 파일 및 README를 설정하여 Layer 생성을 자동화합니다.다음 명령은 도구를 실행하여 poky 디렉토리에 meta-mylayer라는 레이어를 생성합니다.$ cd poky$ bitbake-layers create-layer meta-mylayerNOTE: Starting bitbake server...Add your new layer with 'bitbake-layers add-layer meta-mylayer'레이어와 레이어 생성 방법에 대한 자세한 내용은 Yocto 프로젝트 개발 작업 매뉴얼의 bitbake-layers 스크립트를 사용하여 일반 레이어 생성 섹션을 참조하십시오.참고 – https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html" }, { "title": "[Yocto] Yocto overview", "url": "/posts/yocto-overview/", "categories": "Yocto", "tags": "yocto, embedded, programming", "date": "2022-09-22 00:00:00 +0900", "snippet": "Yocto?임베디드 개발을 하다보면 늘 개발보드의 아키텍쳐는 무엇인가 OS와 부트로더는 어떤것이고 어떠한 버전을 사용할 것인가 매번 확인하고 환경을 만드는데 드는 비용과 시간이 많은것을 느낀다.Yocto는 이런 환경을 한번에 셋팅하고 형상관리 되도록 도와주는 시스템이다. Yocto Project는 하드웨어 아키텍처에 관계없이 임베디드 제품에 대한 커스텀 Linux 기반 시스템을 개발자가 작성할 수 있도록 지원하는 오픈 소스 협업 프로젝트입니다. 이 프로젝트에서는 유연한 툴세트와 세계 각지의 임베디드 개발자가 테크놀로지, 소프트웨어 스택, 구성 및 베스트 프랙티스를 공유하여 임베디드 디바이스용으로 맞춤형 Linux 이미지를 작성할 수 있는 공간을 제공합니다.이 프로젝트는 하드웨어 지원 및 소프트웨어 스택을 제공하기 위한 표준을 제공하여 소프트웨어 구성 및 빌드를 교환할 수 있도록 합니다. 사용자는 이 툴을 사용하여 여러 하드웨어 플랫폼 및 소프트웨어 스택에 대한 커스터마이즈를 유지보수 및 확장 가능한 방법으로 구축하고 지원할 수 있습니다.Yocto 다운로드 및 빌드git clone git://git.yoctoproject.org/pokycd pokysource oe-init-build-envbitbake core-image-satoYocto project의 기본 구성요소 Configuration Files : 변수, 사용자 정의 변수 및 하드웨어 구성 정보의 글로벌 정의를 저장하는 파일입니다. 이들은 빌드 시스템에 특정 플랫폼을 지원하기 위해 무엇을 빌드하고 이미지에 포함시킬지 지시합니다. Recipe : 메타데이터의 가장 일반적인 형식입니다.레시피에는 바이너리 이미지를 빌드하기 위해 사용되는 패키지의 설정 및 태스크(설명서) 목록이 포함됩니다. 레시피는 소스 코드를 어디서 얻을 수 있는지와 적용할 패치를 설명합니다. 레시피는 구성 및 컴파일 옵션뿐만 아니라 라이브러리 또는 기타 레시피에 대한 종속성을 설명합니다.이는 Layer로 저장된다. OpenEmbedded-Core : oe-core는 Yocto Project를 포함한 OpenEmbedded에서 파생된 많은 시스템에서 공통되는 기초 레시피, 클래스 및 관련 파일로 구성된 메타데이터입니다. OpenEmbedded 커뮤니티에 의해 개발된 오리지널 저장소의 큐레이션된 서브셋으로, 지속적으로 검증된 소규모 핵심 레시피 세트로 분할되어 엄격하게 관리되고 품질 보증된 핵심 레시피 세트가 생성됩니다. Poky: 레퍼런스 임베디드 디스트리뷰션 및 레퍼런스 테스트 구성에서는 1) 디스트리뷰션의 커스터마이즈 방법, 2) Yocto Project 컴포넌트의 테스트 방법, 3) Poky를 사용하여 Yocto Project를 다운로드하기 위한 수단으로 사용할 수 있습니다. Poky는 제품 수준의 DISTRO가 아니라 커스터마이즈의 출발점이 됩니다. Poky는 oe-core 위에 있는 통합 Layer입니다. Build system - \"Bitbake\" : 명령(수신) 및 구성 데이터를 해석하는 스케줄러 및 실행 엔진. 종속성 트리를 생성하여 컴파일을 주문하고 포함된 코드의 컴파일을 스케줄링한 후 마지막으로 지정된 커스텀 Linux 이미지(배포)를 빌드합니다. BitBake는 Make 같은 빌드 툴입니다. BitBake 레시피는 특정 패키지의 빌드 방법을 지정합니다. 여기에는 모든 패키지 종속성, 소스 코드 위치, 구성, 컴파일, 빌드, 설치 및 제거 지침이 포함됩니다. 레시피는 패키지의 메타데이터도 표준 변수에 저장합니다.관련 레시피가 층으로 통합됩니다. 빌드 프로세스 중에 의존관계가 추적되고 패키지의 네이티브 또는 크로스 컴파일이 수행됩니다. 크로스 빌드 설정의 첫 번째 단계로 프레임워크는 타깃 플랫폼에 적합한 크로스 컴파일러 툴 체인(Extensible SDK)을 작성하려고 합니다. Package: 빌드 시스템의 출력인 최종 이미지 파일. Extensible Software Development Kit (ESDK): 다른 애플리케이션 개발자가 코드를 사용할 수 있도록 라이브러리 및 프로그래밍 변경 사항을 이미지에 통합할 수 있는 애플리케이션 개발자를 위한 커스텀 SDK입니다. Cross-compiler, 빌드 출력 패키지 등 모든게 포함되어 있습니다. Image: 디바이스에 로드하기 위한 Linux 이미지Yocto 워크플로우 개발자는 아키텍처, 정책, 패치 및 구성 세부사항을 지정합니다. 빌드 시스템은 지정된 위치에서 소스 코드를 가져와 다운로드합니다. 이 프로젝트는 tarball과 같은 표준 메서드나 git과 같은 소스 코드 저장소 시스템을 지원합니다. 다운로드가 완료되면 소스가 패치가 적용되는 로컬워크 영역으로 추출되어 소프트웨어의 구성 및 컴파일을 위한 일반적인 절차가 실행됩니다. 소프트웨어는 선택한 바이너리 패키지 형식(deb, rpm 또는 ipk)을 사용하여 소프트웨어를 롤업하는 임시 스테이징 영역에 설치됩니다. 빌드 프로세스 전체에서 다양한 QA 및 건전성 검사가 실행됩니다. 바이너리가 생성되면 바이너리 패키지 피드가 생성되어 최종 루트 파일이미지 작성에 사용됩니다. 파일 시스템 이미지가 생성됩니다.참고 – https://www.yoctoproject.org/" }, { "title": "[Python] 튜토리얼!", "url": "/posts/python-tutorial/", "categories": "Python", "tags": "python, programming, tutorial", "date": "2022-07-20 00:00:00 +0900", "snippet": "Pythonpython 사용이 잦아지며 Tutorial 내용을 작성한다.파이썬(Python)은 1991년 네덜란드계 프로그래머인 귀도 반 로섬이 발표한 고급 프로그래밍 언어로, 플랫폼에 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed) 대화형 언어이다. 파이썬이라는 이름은 귀도가 좋아하는 코미디인〈Monty Python’s Flying Circus〉에서 따온 것이다. 이름에서 고대신화에 나오는 커다란 뱀을 연상하는 경우도 있겠지만, 이와는 무관하다. 다만 로고에는 뱀 두마리가 형상화되어 있다. 파이썬은 비영리의 파이썬 소프트웨어 재단이 관리하는 개방형, 공동체 기반 개발 모델을 가지고 있다. C언어로 구현된 사이썬 구현이 사실상의 표준이다. 파이썬 3.9 버전 이상부터는 64비트로 바뀌면서 32비트 컴퓨터에서 사용할 수 없다. 파이썬 3.9 버전 이상을 사용하려면 64비트 컴퓨터여야 한다.주요 특징 실행 시간에 자료형을 검사하는 동적 타이핑(dynamic typing)을 지원합니다. 객체의 멤버에 무제한으로 접근할 수 있습니다. 모듈, 클래스, 객체와 같은 언어의 요소가 내부에서 접근할 수 있습니다. 리플렉션을 이용한 기술을 쓸 수 있습니다.해석 프로그램의 종류 C파이썬 : C로 작성된 인터프리터. 스택리스 파이썬 : C 스택을 사용하지 않는 인터프리터. 자이썬( 제이파이썬 : JPython) : 자바 가상 머신 용 인터프리터. IronPython : .NET 플랫폼 용 인터프리터. PyPy : 파이썬으로 작성된 파이썬 인터프리터. – https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%B4%EC%8D%ACPython style guidePEP8는 python style guide가 작성된 문서이다.개인적인 생각으로는 style guide는 반드시 필요하며 이유는 아래와 같다. 가독성 개발자는 코드를 작성하는 시간보다 읽는 시간이 많다. 각 파일별 혹은 모듈별 또는 구역별 코드의 style이 일괄적이지 않다면 불필요한 리소스를 사용하게 된다. 일관성 e.g. cpp int32_t m_variable_name; int32_t member_variable_name_; int32_t MemberVariableName; 협업에 있어 일관적이지 못한 코드는 리소스 낭비를 일으킨다. 결론은 style guide를 지키는 것이 같이 일하는 동료 그리고 나 를 위한 일이다. – https://peps.python.org/pep-0008주석프로그램에서 주석이란? 프로그램의 실행에는 전혀 관여하지않으면서 프로그램 코드 중간 중간에 코드에 대한 자세한 설명을 첨부하는것을 말합니다.행 단위 주석\"\"\" 주석 내용을 작성하세요 \"\"\"\" 주석 내용을 작성하세요주석 내용을 작성하세요주석 내용을 작성하세요주석 내용을 작성하세요주석 내용을 작성하세요\"블록 단위 주석# 주석 내용을 작성하세요# 주석 내용을 작성하세요# 주석 내용을 작성하세요입출력표준 출력Python 에선 표준 출력 함수인 print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)를 제공한다.print('one', 'two', 'three', '1', '2', '3')print('one', 'two', 'three', '1', '2', '3', sep='-')print('end value test,', end='---&gt;')print('end next value')one two three 1 2 3 one-two-three-1-2-3 end value test,---&gt;end next value 표준 입력Python 에선 표준 출력 함수인 input([prompt])를 제공한다.print('이름을 입력하세요', end=\"\")name = input();print(\"이름 : {0}, type : {1}\".format(name,type(name)))name = input('이름을 입력하세요 ');print(\"이름 : {0}, type : {1}\".format(name,type(name)))name = input('아무것도 입력하지 말고 EOF(Ctrl+D 또는 Ctrl+Z+Enter)를 입력해보세요');이름을 입력하세요wonu 이름 : wonu, type : &lt;class 'str'&gt; 이름을 입력하세요 wonu 이름 : wonu, type : &lt;class 'str'&gt; 아무것도 입력하지 말고 EOF(Ctrl+D 또는 Ctrl+Z+Enter)를 입력해보세요Traceback (most recent call last): File \"test2.py\", line 57, in &lt;module&gt; name = input('아무것도 입력하지 말고 EOF(Ctrl+D 또는 Ctrl+Z+Enter)를 입력해보세요'); EOFError TipsUnderscore(_)로 시작하는 파이썬 클래스명PEP8PEP8에 명시적으로 언더스코어가 붙은 클래스가 정의되어 있지는 않지만, 문서의 일부에서 언더스코어로 시작하는 클래스에 대한 언급이 있습니다. Even with all set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore. – https://www.python.org/dev/peps/pep-0008/#public-and-internal-interfaces파이썬 표준라이브러리 코드파이썬 표준라이브러의 코드에서 이 방식으로 클래스를 사용하고 있습니다.class _HashedSeq(list): ... – https://github.com/python/cpython/blob/master/Lib/functools.py#L439!?언더스코어로 시작하는 변수나 클래스는 from import *과 같은 Asterisk를 사용하는 import문에 자동으로 불러와지지 않는다고 합니다.참고 – https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%B4%EC%8D%AC – https://wikidocs.net/book/2070 – https://www.lhy.kr/python-class-name-startwith-underscore" }, { "title": "Blog post를 위한 markdown 사용법", "url": "/posts/how-to-use-markdown/", "categories": "Blog", "tags": "blog, jekyll, markdown", "date": "2022-07-19 00:00:00 +0900", "snippet": "Gihub.io 를 통해 blogging을 하다보니 Markdown에 대한 정리가 필요하다.Markdown? 마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. HTML과 리치 텍스트(RTF) 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다. – Link 위키백과 – New tab Link 위키백과 사용법제목제목의 범위는 1 - 6 까지 사용 할 수 있다.# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6제목3제목4제목5제목6강조*기울기 기울기 기울기 기울기 기울기*_기울기 기울기 기울기 기울기 기울기_**굵게 굵게 굵게 굵게 굵게**__굵게 굵게 굵게 굵게 굵게__*기울기 **기울기 굵게** 기울기*~~취소선~~기울기 기울기 기울기 기울기 기울기기울기 기울기 기울기 기울기 기울기굵게 굵게 굵게 굵게 굵게굵게 굵게 굵게 굵게 굵게기울기 기울기 굵게 기울기취소선목록Unordered- 내용 1- 내용 2 - 내용 2-1 - 내용 2-2* 내용 1* 내용 2 * 내용 2-1 * 내용 2-2+ 내용 1+ 내용 2 + 내용 2-1 + 내용 2-2Ordered1. 내용 12. 내용 2 1. 내용 2-1 2. 내용 2-2Unordered 내용 1 내용 2 내용 2-1 내용 2-2 내용 1 내용 2 내용 2-1 내용 2-2 내용 1 내용 2 내용 2-1 내용 2-2 Ordered 내용 1 내용 2 내용 2-1 내용 2-2 이미지# 첫 번째![Image name](/image/address) # 두 번째&lt;a href=\"#\"&gt;&lt;img src=\"https://image_address\" width=\"300px\" height=\"300px\" title=\"px 설정\" alt=\"image\"&gt;&lt;/a&gt; # 세 번째&lt;a href=\"#이미지\"&gt;&lt;img src=\"https://image_address\" width=\"40%\" height=\"30%\" title=\"px 설정2\" alt=\"image\"&gt;&lt;/a&gt; 링크# 첫 번째[첫 번째 링크][id_1][id_1]: https://first_link_uri# 두 번째[두 번째 링크](https://second_link_uri)# 세 번째 (새 탭 링크)[세 번째 링크][id_2]{:target=\"_blank\"}[id_2]: https://third_link_uri# 네 번째 (새 탭 링크)[네 번째 링크](https://fourth_link_uri \"Hinting\"){:target=\"_blank\"}# 다섯 번째 (이미지 링크)&lt;a href=\"https://image_address\"&gt;&lt;img src=\"https://image_address\" width=\"300px\" alt=\"image\"&gt;&lt;/a&gt; # 여섯 번째* 외부링크: &lt;http://example.com&gt;GoogleAmazonApple(new tab)GitHub(new tab) 외부링크: http://example.com코드 블록 ```cpp #include &lt;iostream&gt; int32_t main() { return 0; } ``` This is a normal paragraph: #include &lt;iostream&gt; int32_t main() { return 0; } end code block.#include &lt;iostream&gt;int32_t main() { return 0;}This is a normal paragraph:#include &lt;iostream&gt;int32_t main() { return 0;}end code block.인라인 코드Blah blah `std::cout &lt;&lt; \"출력\" &lt;&lt; std::endl;` blah blah~Blah blah std::cout &lt;&lt; \"출력\" &lt;&lt; std::endl; blah blah~—인용구Blah blah ~&gt; Block quotes&gt; &gt; Block quotes 2&gt; &gt; -- Block quotes 3&gt;&gt; Block quotes 4 &gt;&gt; -- Block quotes 5 Blah blah ~ Block quotes Block quotes 2 – Block quotes 3 Block quotes 4– Block quotes 5 테이블| Name | Name || --- | --- || column a-2 | column b-2 || column a-3 | column b-3 | Name First Name Second column a-2 column b-2 column a-3 column b-3 체크박스 Complete 1 Incomplete 1 Incomplete 2 Complete2수평선 &lt;hr/&gt;* * *********- - ---------------------------------------- *` Github emojiGitHub supports emoji! :+1: :sparkles: :camel: :tada: :rocket: :metal: :octocat: :smiley: GitHub supports emoji! :+1: :sparkles: :camel: :tada: :rocket: :metal: :octocat::smiley:참고 – https://post.naver.com/viewer/postView.nhn?volumeNo=24627214&amp;memberNo=42458017 – https://gist.github.com/ihoneymon/652be052a0727ad59601" } ]
